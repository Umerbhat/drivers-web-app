import {
  createSlice,
  PayloadAction,
  createEntityAdapter,
} from "@reduxjs/toolkit";
import {
  getDeliveryList,
  getDeliveryDetails,
  setDeliveryStatus,
} from "./asyncActions";
import {
  FETCH_DELIVERY_LIST,
  FETCH_DELIVERY,
  POST_DELIVERY_STATUS,
} from "./constants";
import { TDeliveryListState } from "./types";

// NOTE: Helper adapter to normalize data and gives helper functions to do CRUD in it.
const deliveryListAdapter = createEntityAdapter<TDeliveryListState["data"]>();

export const initialState: TDeliveryListState = {
  data: deliveryListAdapter.getInitialState({}),
  apiStatus: {
    [FETCH_DELIVERY_LIST]: "idle",
    [FETCH_DELIVERY]: "idle",
    [POST_DELIVERY_STATUS]: "idle",
  },
  activeDeliveryId: null,
};

export const deliveryListSlice = createSlice({
  name: "deliveryTracker",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setActiveDelivery: (state, action: PayloadAction<string>) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.activeDeliveryId = action.payload;
    },
    resetActiveDelivery: (state) => {
      state.activeDeliveryId = null;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getDeliveryList.pending, (state, action) => {
        state.apiStatus[FETCH_DELIVERY_LIST] = "loading";
      })
      .addCase(getDeliveryList.fulfilled, (state, action) => {
        state.apiStatus[FETCH_DELIVERY_LIST] = "success";
        // TODO: use setAll when listing API has status as well
        deliveryListAdapter.upsertMany(state.data as any, action);
      })
      .addCase(getDeliveryList.rejected, (state, action) => {
        state.apiStatus[FETCH_DELIVERY_LIST] = "failed";
      })
      .addCase(getDeliveryDetails.pending, (state) => {
        state.apiStatus[FETCH_DELIVERY] = "loading";
      })
      .addCase(getDeliveryDetails.fulfilled, (state, action) => {
        state.apiStatus[FETCH_DELIVERY] = "success";
        deliveryListAdapter.setOne(state.data as any, action);
      })
      .addCase(getDeliveryDetails.rejected, (state, action) => {
        state.apiStatus[FETCH_DELIVERY] = "failed";
      })
      .addCase(setDeliveryStatus.pending, (state) => {
        state.apiStatus[POST_DELIVERY_STATUS] = "loading";
      })
      .addCase(setDeliveryStatus.fulfilled, (state, action) => {
        // TODO: Remove hack when API issue (not returning submitted data properly) is resolved
        const status = action.meta.arg.status;
        const id = action.meta.arg.deliveryId;
        action.payload = { id, status };
        // hack ends
        state.apiStatus[POST_DELIVERY_STATUS] = "success";
        state.activeDeliveryId = null;

        deliveryListAdapter.upsertOne(state.data as any, action);
      })
      .addCase(setDeliveryStatus.rejected, (state, action) => {
        state.apiStatus[POST_DELIVERY_STATUS] = "failed";
      });
  },
});

export default deliveryListSlice.reducer;

// Direct actions

export const { setActiveDelivery, resetActiveDelivery } =
  deliveryListSlice.actions;
